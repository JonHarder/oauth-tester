* OAuth Client testing server
This is a testing Open ID Connect compliant identity provider server. It aims to be particularly verbose in providing feedback to developers wishing to implement SSO using Open ID Connect into their service.
** Dependencies
- go 1.17
** Development Dependencies
- CompileDaemeon :: Used for the local dev server with automatic server rebuilding.
#+BEGIN_SRC sh
go install github.com/githubnemo/CompileDaemon@latest
#+END_SRC

** Building
#+begin_src sh
make
#+end_src

Alternatively, you can build and run the server with hot binary reloading using [[https://github.com/githubnemo/CompileDaemon][CompileDaemon]]
#+BEGIN_SRC sh
make dev
#+END_SRC

** Installing
#+BEGIN_SRC sh
make install
#+END_SRC

** Running
#+begin_src
Usage of oauth-server:
  -config string
    	Path to configuration file (default "config.json")
  -port int
    	Port to run server on (default 8001)
#+end_src

** Test suite
#+BEGIN_SRC sh
make test
#+END_SRC

** Documentation
[[file:Docs.org][link]]

** Configuration
This reads from a =config.json= file, which expects an object with two
keys: ~applications~, and ~users~.

In addition to these, an optional ~settings~ key will be read if provided which configures the various features of the server

*** applications
A list of objects, each of the form:

#+begin_src json
{
  "clientId": "string",
  "clientSecret": "string",
  "callback": "url",
  "name": "string"
}
#+end_src

*** users
A list of objects, each of the form:

#+begin_src json
{
  "email": "email",
  "password": "string",
  "family_name": "string",
  "given_name": "string"
}
#+end_src

*** settings
An object of the form:

#+BEGIN_SRC json
{
  "pkce": {
    "required": "bool",
    "allowed_code_challenge_methods": ["string"]
  }
}
#+END_SRC

**** =pkce.required= 
This instructs the authorization server whether or not to enforce PKCE verification. When set to =true=, any authorization request that does not contain a =code_challenge= will immediately fail.

If set to false, authorize requests will not fail if =code_challenge= is not provided, however, if a client does provide a =code_challenge=, it will be verified in the token exchange using the =code_verifier= and can still fail if the verifier is not valid.

**** =pkce.allowed_code_challenge_methods=
*NOTE* /currently not supported/

This is a list of allowed =code_challenge_method= values. If an authorize request provides a =code_challenge_method= not present in this list, the request will be rejected.

** Enhancements
*** DONE [#A] handle ~implicit~ flow
CLOSED: [2022-04-02 Sat 10:49]
- =response_type= :: ~token~
- =response_type= :: ~id_token~
*** DONE add landing page
CLOSED: [2022-04-02 Sat 10:55]
*** DONE add settings page
CLOSED: [2022-04-02 Sat 10:49]
*** TODO add config for which flows are accepted
*** TODO add db
*** TODO Noman + consul for full application deployment
- incorporate db
*** TODO [#B] Handle RS256 JWT signing alg
**** TODO need to provide jwks url
*** TODO Session management
[[https://openid.net/specs/openid-connect-session-1_0.html][openid docs]]
*** TODO Integrate a server framework
- need to do some research to find a suitable one
*** TODO verify =code_challenge_method= against ~settings.pkce.allowed_methods~
*** SOMEDAY Handle different =response_type= flows
*** DONE Implement scope access test endpoint
- using auth header, determine if the requested content is allowed to access it given the scopes it was authorized for
#+BEGIN_SRC restclient
GET http://localhost:8001/scope-test?resource=foo
Authorization: Bearer as98htaiOIENas89398wtMTCCDpu7
#+END_SRC

should respond with 403 if authorize request did not contain the ~foo~ scope.
*** DONE refactor =validation= package
- move grant type specific logic into specific package =grants=
#+BEGIN_SRC go
package grants

type TokenResponse struct
{

}

type Grant interface {
   CreateResponse() (*TokenResponse, error)
}

type AuthorizationCode struct {
  ClientId     string
  ClientSecret string
  Code         string
  Pkce         *pkce.PKCE
}

type RefreshToken struct {
  ClientId     string
  ClientSecret string
  RefreshToken string
}

func (req AuthorizatonCode) CreateResponse() (*TokenResponse, error) {

}

func (req RefreshToken) CreateResponse() (*TokenResponse, error) {

}
#+END_SRC
*** DONE move map objects from =types= package into separate =db= package
- anticipating eventual actual database
- makes more clear what those maps are doing
*** DONE refactor token request verification
- using =TokenRequest= interface
*** DONE handle user information endpoint
*** DONE add config block to ~config.json~
*** DONE Dockerize
